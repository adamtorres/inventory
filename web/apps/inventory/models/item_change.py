from django.contrib.contenttypes import fields as ct_fields
from django.contrib.contenttypes import models as ct_models
from django.db import models, transaction

import uuid

from .item import Item
from .change import Change


class ItemChange(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    item = models.ForeignKey(Item, on_delete=models.CASCADE, null=True, blank=True)
    change = models.ForeignKey(Change, on_delete=models.CASCADE, related_name="items")

    # Link this to a vendor order, donation, local store pickup, etc.  Actual instance of change, not the company.
    # This is the line item on the order or donation.  Not the order or donation.
    source_item_limit = (
        models.Q(app_label='incoming', model='incomingitem')
        | models.Q(app_label='inventory', model='adjustmentitem')
        | models.Q(app_label='inventory', model='usageitem')
    )
    source_item = ct_fields.GenericForeignKey('source_item_content_type', 'source_item_object_id')
    source_item_content_type = models.ForeignKey(
        ct_models.ContentType, on_delete=models.CASCADE, null=True, blank=True, limit_choices_to=source_item_limit)
    source_item_object_id = models.UUIDField(null=True, blank=True)

    previous_quantity = models.DecimalField(max_digits=10, decimal_places=4, null=False, blank=False, default=0)
    # Positive for adding stuff to inventory, negative for using stuff.
    change_quantity = models.DecimalField(max_digits=10, decimal_places=4, null=False, blank=False)
    new_quantity = models.DecimalField(max_digits=10, decimal_places=4, null=False, blank=False, default=0)

    applied = models.BooleanField("The change been applied", default=False, null=False)
    created = models.DateTimeField(auto_now_add=True, null=False, blank=False, editable=False)

    def __str__(self):
        plus_minus = "+" if self.change_quantity >= 0 else "-"
        applied = "âœ“" if self.applied else " "
        item_name = self.item.common_item.name if self.item else "<unknown>"
        return f"{applied} {item_name} {plus_minus}{abs(self.change_quantity)}"

# inventory change item
#     - single item with a change to the quantity.
#     - This is generated by processing an incoming order/donation.
#     - There could be multiples of these for a single outgoing use.  If the usage claims 3 bags of flour and there are
#         2 inventory items of flour with qty=1 and qty=2, then both will get a change item record.
#     - Basically, the system will find all the flour inventory items (oldest first) and keep subtracting until the
#         change order is satisfied.
#     - This table can act as a history.
#     inventory change - link to the change group
#     inventory item - link to the inventory item
#     source item - link to the line item from the vendor order/donation/whatever.
#     previous quantity - quantity of the item before applying the change.
#     change quantity - positive/negative quantity to apply
#     new quantity - quantity of the item after applying the change

    def apply_change(self):
        if self.applied:
            return
        with transaction.atomic():
            if not self.item:
                i = self.source_item.item.common_item.make_item(unit_size=self.source_item.unit_size)
                self.item = i
                self.item.original_quantity = self.change_quantity
            self.previous_quantity = self.item.current_quantity
            self.item.current_quantity += self.change_quantity
            self.item.save()
            self.new_quantity = self.item.current_quantity
            self.applied = True
            self.save()
